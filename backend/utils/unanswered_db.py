"""
SQLite database handler for storing unanswered or low-confidence queries.
This module tracks queries that need human review or intervention.
"""
import sqlite3
import os
from datetime import datetime
from typing import List, Dict, Optional
from contextlib import contextmanager


# Database path - stores in backend directory
DB_PATH = os.path.join(os.path.dirname(os.path.dirname(__file__)), "unanswered_queries.db")


@contextmanager
def get_db_connection():
    """Context manager for database connections."""
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row  # Returns dict-like rows
    try:
        yield conn
        conn.commit()
    except Exception as e:
        conn.rollback()
        raise e
    finally:
        conn.close()


def init_database():
    """Initialize the database with required tables."""
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS unanswered_queries (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                original_message TEXT NOT NULL,
                generated_query TEXT NOT NULL,
                attempted_solution TEXT,
                generated_reply TEXT,
                confidence_score REAL,
                reason TEXT,
                timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
                status TEXT DEFAULT 'pending',
                human_response TEXT,
                resolved_at DATETIME
            )
        """)
        
        # Create learned Q&A table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS learned_qna (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                query TEXT NOT NULL,
                approved_answer TEXT NOT NULL,
                query_embedding BLOB NOT NULL,
                usage_count INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_status 
            ON unanswered_queries(status)
        """)
        
        cursor.execute("""
            CREATE INDEX IF NOT EXISTS idx_timestamp 
            ON unanswered_queries(timestamp DESC)
        """)
        
        print(f"âœ… Database initialized at: {DB_PATH}")


def save_low_confidence_query(
    original_message: str,
    generated_query: str,
    attempted_solution: str,
    generated_reply: str,
    confidence_score: float,
    reason: str = "Low confidence"
) -> int:
    """
    Save a low-confidence or unanswered query to the database.
    
    Args:
        original_message: The original WhatsApp message from user
        generated_query: The structured query generated by query_generator_agent
        attempted_solution: The solution found by solution_generator_agent
        generated_reply: The reply generated by reply_generator
        confidence_score: Confidence score (0-100)
        reason: Reason for saving (e.g., "Low confidence", "No solution found")
    
    Returns:
        ID of the inserted record
    """
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO unanswered_queries 
            (original_message, generated_query, attempted_solution, 
             generated_reply, confidence_score, reason)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (
            original_message,
            generated_query,
            attempted_solution,
            generated_reply,
            confidence_score,
            reason
        ))
        
        query_id = cursor.lastrowid
        print(f"ðŸ“ Saved low-confidence query (ID: {query_id}, Confidence: {confidence_score}%)")
        return query_id


def get_pending_queries(limit: int = 50, offset: int = 0) -> List[Dict]:
    """
    Retrieve pending queries that need human review.
    
    Args:
        limit: Maximum number of queries to return
        offset: Offset for pagination
    
    Returns:
        List of query dictionaries
    """
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            SELECT 
                id,
                original_message,
                generated_query,
                attempted_solution,
                generated_reply,
                confidence_score,
                reason,
                timestamp,
                status
            FROM unanswered_queries
            WHERE status = 'pending'
            ORDER BY timestamp DESC
            LIMIT ? OFFSET ?
        """, (limit, offset))
        
        rows = cursor.fetchall()
        return [dict(row) for row in rows]


def get_all_queries(
    status: Optional[str] = None,
    limit: int = 100,
    offset: int = 0
) -> List[Dict]:
    """
    Retrieve all queries, optionally filtered by status.
    
    Args:
        status: Filter by status ('pending', 'resolved', 'dismissed')
        limit: Maximum number of queries to return
        offset: Offset for pagination
    
    Returns:
        List of query dictionaries
    """
    with get_db_connection() as conn:
        cursor = conn.cursor()
        
        if status:
            cursor.execute("""
                SELECT * FROM unanswered_queries
                WHERE status = ?
                ORDER BY timestamp DESC
                LIMIT ? OFFSET ?
            """, (status, limit, offset))
        else:
            cursor.execute("""
                SELECT * FROM unanswered_queries
                ORDER BY timestamp DESC
                LIMIT ? OFFSET ?
            """, (limit, offset))
        
        rows = cursor.fetchall()
        return [dict(row) for row in rows]


def get_query_stats() -> Dict:
    """
    Get statistics about queries in the database.
    
    Returns:
        Dictionary with statistics
    """
    with get_db_connection() as conn:
        cursor = conn.cursor()
        
        # Total queries
        cursor.execute("SELECT COUNT(*) as total FROM unanswered_queries")
        total = cursor.fetchone()["total"]
        
        # Pending queries
        cursor.execute("SELECT COUNT(*) as pending FROM unanswered_queries WHERE status = 'pending'")
        pending = cursor.fetchone()["pending"]
        
        # Resolved queries
        cursor.execute("SELECT COUNT(*) as resolved FROM unanswered_queries WHERE status = 'resolved'")
        resolved = cursor.fetchone()["resolved"]
        
        # Average confidence
        cursor.execute("SELECT AVG(confidence_score) as avg_confidence FROM unanswered_queries")
        avg_confidence = cursor.fetchone()["avg_confidence"] or 0
        
        return {
            "total": total,
            "pending": pending,
            "resolved": resolved,
            "dismissed": total - pending - resolved,
            "average_confidence": round(avg_confidence, 2)
        }


def update_query_status(
    query_id: int,
    status: str,
    human_response: Optional[str] = None
) -> bool:
    """
    Update the status of a query.
    
    Args:
        query_id: ID of the query to update
        status: New status ('resolved', 'pending', 'dismissed')
        human_response: Optional human response to the query
    
    Returns:
        True if update was successful
    """
    with get_db_connection() as conn:
        cursor = conn.cursor()
        
        if status == 'resolved':
            cursor.execute("""
                UPDATE unanswered_queries
                SET status = ?,
                    human_response = ?,
                    resolved_at = CURRENT_TIMESTAMP
                WHERE id = ?
            """, (status, human_response, query_id))
        else:
            cursor.execute("""
                UPDATE unanswered_queries
                SET status = ?,
                    human_response = ?
                WHERE id = ?
            """, (status, human_response, query_id))
        
        return cursor.rowcount > 0


def delete_query(query_id: int) -> bool:
    """
    Delete a query from the database.
    
    Args:
        query_id: ID of the query to delete
    
    Returns:
        True if deletion was successful
    """
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("DELETE FROM unanswered_queries WHERE id = ?", (query_id,))
        return cursor.rowcount > 0


def save_learned_qna(query: str, approved_answer: str, query_embedding: bytes) -> int:
    """Save approved Q&A with embedding."""
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO learned_qna (query, approved_answer, query_embedding)
            VALUES (?, ?, ?)
        """, (query, approved_answer, query_embedding))
        return cursor.lastrowid


def search_learned_qna(query_embedding: bytes, threshold: float = 0.85) -> Optional[Dict]:
    """Search learned Q&As by semantic similarity."""
    import numpy as np
    
    with get_db_connection() as conn:
        cursor = conn.cursor()
        cursor.execute("SELECT id, query, approved_answer, query_embedding, usage_count FROM learned_qna")
        rows = cursor.fetchall()
        
        if not rows:
            return None
        
        query_vec = np.frombuffer(query_embedding, dtype=np.float32)
        best_match = None
        best_score = threshold
        
        for row in rows:
            stored_vec = np.frombuffer(row["query_embedding"], dtype=np.float32)
            similarity = np.dot(query_vec, stored_vec) / (np.linalg.norm(query_vec) * np.linalg.norm(stored_vec))
            
            if similarity > best_score:
                best_score = similarity
                best_match = {
                    "id": row["id"],
                    "query": row["query"],
                    "answer": row["approved_answer"],
                    "similarity": float(similarity),
                    "usage_count": row["usage_count"]
                }
        
        if best_match:
            # Increment usage count
            cursor.execute("UPDATE learned_qna SET usage_count = usage_count + 1 WHERE id = ?", (best_match["id"],))
            conn.commit()
        
        return best_match



init_database()

